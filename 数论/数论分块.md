# 数论分块

## 目录 <!-- omit in toc -->
- [数论分块](#数论分块)
	- [整数分块](#整数分块)
		- [另外的不会的东西](#另外的不会的东西)

## 整数分块

* [2020牛客暑期多校训练营（第七场）]https://ac.nowcoder.com/acm/contest/5672/H

> 题解：
> 这个题其实难点在于如何看出来是一个整数分块的板子，因为我个人认为若不是看了大家的题解很难把这个题和整数分块相联系，首先做这个题我觉得要很熟悉整数分块的知识，还有处理题目的技巧。

> 先看题目的条件，总结一下：
> 推出第一条结论：只有在满足n=1，n是k的倍数，或者n-1是k的倍数时，(n,k)是传奇元组。我们写出来是三种情况（1，k） （xk，k）  （xk+1，k）
> 那么我们从数据范围1e12入手，（1，k）是k种先不用管，先考虑 n=xk那么x=n/k，我们要求的ans就是要加上x这里的除是整除，我们枚举k，从2到k，每一个k对应的在N范围内的的n有x种（不会超时）然后带入（N-1）再算一遍就好了
> 注：要从2枚举因为从一的话会枚举重复这样的（1，k）元素。

> （代码没啥好说的感觉写注释也没啥用，都是板子）
```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll; 
const int mod = 1e9+7;
ll ans =0;
ll n,k;
void solve(ll nn){
	for(ll l = 2, r; l <= nn && l<=k; l = r + 1){//注意区间端点是小于k的
	    r = min(nn / (nn / l) , k);
	    ans += (nn / l)%mod*((r - l + 1)%mod)%mod;
	    ans%=mod;
	}
}
int main(){
	cin>>n>>k;
	solve(n);
	solve(n-1);
	cout<<(ans+n+k-1)%mod;//减一是因为减去重复枚举的（1，1）
}
```
* [最后照例贴上参考的CSDN（里面有例题）]https://blog.csdn.net/weixin_43627118/article/details/104024380?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param

### 另外的不会的东西
* 积性函数
* 莫比乌斯反演
  
数论分块是莫比乌斯反演一个很重要的的前置知识（基本都要用到这个玩意）
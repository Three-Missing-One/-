[TOC]
# 数论

## 带模的快速乘
```cpp
inline ll qmult(ll a, ll b, ll mod){
	ll ans = 0;
	while( b > 0 ){
		if( b&1 ) ans = (ans + a) % mod;
		a = ( a + a ) % mod;
		b >>= 1;
	}
	return ans;
}
```

## 带模的快速幂

```c
ll binaryPow(ll a, ll b, ll m){
	ll ans = 1;
    while(b){
        if(b & 1){
            ans = ans * a % m;
        }
        a = a * a % m;
        b >>= 1; 
    } 
    return ans;
}
```

## 矩阵快速幂
```c
const int MAXN=2;
const int MOD=1e4;
class Matrix{
public:
	int m[MAXN][MAXN];
	Matrix(){
		memset(m,0,sizeof(m));
	}
};
Matrix Multi(Matrix a,Matrix b){
	Matrix res;
	for(int i=0;i<MAXN;i++){
		for(int j=0;j<MAXN;j++){
			for(int k=0;k<MAXN;k++){
				res.m[i][j]=(res.m[i][j]+a.m[i][k]*b.m[k][j])%MOD;//取模 
			}
		}
	}
	return res;
}
Matrix fastm(Matrix a,ll n){
	Matrix res;
	for(int i=0;i<MAXN;i++){
		res.m[i][i]=1;
	}
	while(n){
		if(n&1){
			res=Multi(res,a);
		}
		a=Multi(a,a);
		n>>=1;
	}
	return res;
}
```

## 斐波那契矩阵算法：
![fib](./数论img/fib.png)



## 因子分解
```c
int fac[MAXN+10],cnt[MAXN+10];
int getFac(int n){
    int num=0,sum=0,m=sqrt(n+0.5);
    for(int k=2;k<=m;k++){
        sum=0;
        while(n%k==0){
            n/=k;sum++;
        }
        if(sum!=0){
            fac[num]=k;cnt[num++]=sum;
        }
    }
    if(n!=1){
        fac[num]=n;
        cnt[num++]=1;
    }
    return num;//返回的是因子个数；
}
```
优化：用素数除
### 唯一分解定理
  对于任意一个正整数n，一定可以被唯一分解为若干个质数的乘积的形式：$n = {p_1}^{a_1} *{p_2}^{a_2} * … * {p_k}^{a_k}$。

### 因子分解扩展

#### 因子个数 
正整数n的所有不同因子的总个数。
计算公式：D = (a1+1) x (a2+1) x … x (ak+1)。
#### 因子求和

正整数n的所有不同因子的总和。
计算公式：$S = \prod_{i=1}^k[ 1 +p_1+ {+p_2}^2 + … + {p_i}^{ai} ]$
等比数列求和式改写：S = Π[ (pi^(ai+1)-1)/(pi-1) ]


#### 阶乘的因子分解
&ensp;给定正整数n，求n!的因子分解式中质因子p的数量，可以用以下公式求解：
S(p)=求和\[(n/p+n/(p^2)+n/(p^3)+…+n/(p^k)\]，其中 p^k<=n，时间复杂度为O(log(n))。

## GCD与LCM

补充一点：求解gcd问题可以使用两种方法：更相减损法和辗转相除法（欧几里得算法）但是在遇到高精度取模的问题时，可考虑使用更相减损来代替。

更相减损法模板：（认为a > b)

```cpp
int gcd(int a,int b)
{
    if(b == 0) return a;
    else return gcd(b,a - b);
}
```



```c
int gcd(int a,int b){
    return b==0?a:gcd(b,a%b);
}

int lcm(int a,int b){
    return a/gcd(a,b)*b;
}
```
### 关于GCD的一些常用的性质：

(1.结合律) GCD(a,b,c)=GCD(GCD(a,b),c)。
(2.区间) GCD(al,…,ar)=GCD(GCD(al,…,am-1),GCD(am,…,ar))。
(3.分配律) GCD(k*a,k*b)=k*GCD(a,b)。
(4.互质) 若GCD(a,b)=p，则a/p与b/p互质。
(5.线性变换) GCD(a+k*b,b)=GCD(a,b)。
(6.因子分解) GCD(a,b)=Π[pi^min(ai,bi)]。

### 最大公因数

(1.结合律) LCM(a,b,c)=LCM(LCM(a,b),c)。
(2.分配律) LCM(k*a,k*b)=k*LCM(a,b)。
(3.因子分解) LCM(a,b)=Π[pi^max(ai,bi)]。

##  欧拉函数
### 计算方法：
φ(n) = Π[ pi^(ai-1) ] x Π[ pi-1 ]。
通式：![e](./数论img/euler.png)
```c
//求一个数的欧拉函数
ll euler(ll x){
  ll ans=x;//最终答案
  for(ll i=2; i*i<=x; i++){
    if(x%i==0)////找到a的质因数
    {
      ans=ans/i*(i-1);//先进行除法是为了防止中间数据的溢出
      while(x%i==0) x/=i;//x通过质因子分解  x/=i 质因数
    }
  }
  if(x>1) ans=ans/x*(x-1);
  return ans;
}

```
### 性质 
1. 对任意正奇数n，φ(n)=φ(2*n)，特别规定φ(1)=1。
2. 对任意质数n，φ(n)=n-1，φ(n^ k)=(n-1)*n^(k-1)。
3. 对于正整数n的所有因子di，有Σ[φ(di)]=n。



## 扩展欧几里德算法与二元一次方程的整数解

### 拓展欧几里德算法
```cpp
int exgcd(int a,int b,int &x,int &y){
	if(a==0&&b==0)return -1;
	if(b==0){
		x=1;y=0;
		return a;
	}
	int ans=exgcd(b,a%b,y,x);
	y-=a/b*x;
	return ans;
}
```
&ensp;&ensp;变量x和y中存储了方程a*x+b*y=gcd(a,b)的一组整数解;
&ensp;&ensp;函数的返回值是gcd(a,b)，若返回-1，则无解;


## 逆元
### 求逆元
#### 费马小定理求逆元

费马小定理: p为质数,a为任意自然数,且a，p互质,则
![fermat](./数论img/Fermat.png)
所以
![little](./数论img/little.png)
&ensp;&ensp;将a^(p-1) 拆成a^(p-2) *a。a^(p-2)就是a的逆元快速幂求逆元;
&ensp;&ensp;要求mod是质数且与a互质
&ensp;&ensp;时间复杂度O(log(n))

####  欧拉定理 
* 欧拉定理：若a和p互质，则(a^φ(p))%p=1。
* 所以逆元：inv(a)=(a^(φ(p)-1))%p。
* 计算过程首先需要求出欧拉函数，然后使用快速幂优化

只要求a与mod互质，需要欧拉函数与快速幂)

#### 线性打表求逆元

```cpp
const int MAXN=1e5;
const ll  mod=1e9+7;
ll inv[Maxn+10];
void getInv(){
	inv[1]=1;
	for(ll i=2;i<=MAXN;i++){
		inv[i]=(mod-mod/i)*inv[mod%i]%mod;
	}
	return ;
}
```
复杂度O(n)


#### 拓展欧几里德 
&ensp;&ensp;只要求a与mod互质，时间复杂度O(log(n)))

### 扩展欧几里得解线性方程a*x+b*y=c

&ensp;&ensp;线性方程有解的充分必要条件是gcd(a,b)可以整除c。

```c
bool LinearEqu(int a,int b,int c,int &x,int &y){
	int d=exgcd(a,b,x,y);
	if(c%d==0){
		int k=c/d;x*=k;y*=k;
		return true;//有解
	}
	return false;//无解
	//返回一组解，可能为负
}
```
&ensp;&ensp;通解的求法：若(x0,y0)是线性方程a*x+b*y=c的一组特解，那么对于任意的整数t:
&ensp;&ensp;x=x0+(b/gcd(a,b))*t,y=y0-(a/gcd(a,b))*t都是线性方程的解。

### 拓展欧几里德求解同余方程a*x≡b(mod m)。
```c
bool ModularEqu(int a,int b,int m,int &x0){
    int x,y,k;
    int d=exgcd(a,m,x,y);
    if(b%d==0){
        x0=x*(b/d)%m;k=m/d;x0=(x0%k+k)%k;
        return true;
    }
    return false;
}
```
解法：首先将方程改写为a*x-n*y=b的形式，然后使用拓展欧几里德求出一组特解(x0,y0)。
如果题目要求找到最小的正整数解，可以令k=n/gcd(a,n)，这样x的最小正整数解可以通过表达式x=(x0%k+k)%k求出。

## 中国剩余定理
* 中国剩余定理：设正整数N满足线性同余方程组N≡ai(mod pi)，其中 1<=i<=n，pi两两互质，则$N=Σ[ai * Wi * inv(Wi,pi)]\%M$。
其中，$M=Πpi=p1 * p2 * …… * pn$，$Wi=M/pi$，$inv(Wi,pi)$表示Wi在模pi下的逆元。

* 特别注意：这里的模pi必须两两互质。


* 例子：现在有n个苹果，如果3个苹果装一箱会剩1个，5个苹果装一箱会剩2个，7个苹果装一箱会剩3个。问总共有多少个苹果?
* 解法：首先改写为方程组{ n%3=1 , n%5=2, n%7=3 }的形式。
计算M=3x5x7=105，W1=105/3=35，W2=105/5=21，W3=105/7=15。
求逆元inv(35,3)=2，inv(21,5)=1，inv(15,7)=1。
* 计算n=((1x35x2)+(2x21x1)+(3x15x1))%105=157%105=52。
所以总共有52个苹果。

### 模互质的情况
```cpp
//N 方程个数
int N,pp=1;
int exgcd(int a,int b,int &x,int &y);
int inv(int n,int m){
    int x,y,d=exgcd(n,m,x,y);
    return (x%m+m)%m;
}
//解N≡ai(mod pi)
int China(int p[],int a[]){
    int ans=0;
    for(int i=0;i<N;i++)pp*=p[i];
    for(int i=0;i<N;i++){
        int W=pp/p[i];
        ans=(ans+a[i]*W*inv(W,p[i]))%pp;
    }
    return (pp+ans%pp)%pp;//返回满足条件的最小整数解
}

```
### 模不互质的情况
```cpp
// ai余数 mi 模数  n方程个数[1，n] 
ll excrt(ll ai[],ll mi[],int n){
    ll x,y,k;
    ll M=ai[1],ans=mi[1];
    for(int i=2;i<=n;i++){
        ll a=M,b=ai[i],c=(mi[i]-ans%b+b)%b;
        ll gcd=exgcd(a,b,x,y),bg=b/gcd;//要用到扩展欧几里德
        if(c%gcd!=0) return -1; //无解 因为答案可以等于-1，所以可用falg判断有无解 
        x=qmult(x,c/gcd,bg);//有溢出风险要用到快速乘
        ans+=x*M;
        M*=bg;//M为前k个模数的lcm
        ans=(ans%M+M)%M;
    }
    return (ans%M+M)%M;
}
```

## 素数

### 一些定理
素数定理：不超过x的质数的总数π(x)近似于x/ln(x)。
推论：第n个素数的大小：O(nlog(n))
素数的间隔：相邻两个质数的差值非常小，估算在ln^2 (x)以内。
(其他 1) 在10^7的范围以内，质数的个数为664579个。
(其他 2) 1e9范围内相邻两个质数的最大间隔只有282。
(其他 3) 所有除2以外的正偶数都是合数。
(其他 4) 所有除2以外的质数个位数字都是1、3、7、9。

### 素数分布
![11](./数论img/Prime-number-theorem.jpg)

### 筛质数

#### 埃氏筛法筛素数
```cpp
int primes[1005];//素数数组
bool is_prime[Maxn];//1是素数0是合数
void sieve(int n){
	for(int i=0;i<=n;i++) is_prime[i]=true;//可能会慢
	is_prime[0]=is_prime[1]=false;
	for(int i=2;i*i<=n;i++){
		if(is_prime[i]){
			for(int j=i*i;j<=n;j+=i){
				is_prime[j]=0;
			}		
		}
	}//标记
	
	return ;
}
```

#### 线性筛

```cpp
const int MAXN=2e6+10;
int primes[MAXN+10],NUM=0;
bool is_prime[MAXN+10];
void GetPrime2(){
    memset(is_prime, true, sizeof(is_prime));
    is_prime[1] = 0;
    for (int i = 2; i <= MAXN; i++) {
        if (is_prime[i])
            primes[NUM++] = i;
        for (int j = 0; j < NUM && i * primes[j] <= MAXN; j++) {
            is_prime[i * primes[j]] = 0;
            if (i % primes[j] == 0)
                break;
        }
    }
}
```

### Miller Rabinn 素数测试

* 用Miller Rabin快速判断一个
<$2^{63}$的数是不是素数。
的数是不是素数
* $时间复杂度：O(k*log_2 n) $
  
#### 依据
* 费马小定理：若p是质数，a为整数，且（a，p）=1,则有 $a^{p-1}\equiv 1(modp)$
* 二次探测定理：若p是质数，且$0<x<p$则方程$x^2\equiv 1(modp)$的解为$x=1,或者x=p-1$
### 模板
```cpp
typedef unsigned long long ll;
//typedef long long ll;
//ll*ll可能会溢出，所以乘法化加法
/* *************************************************
* Miller_Rabin 算法进行素数测试
* 速度快可以判断一个 < 2^63 的数是不是素数
*
**************************************************/
#include<time.h>
#include<stdlib.h>
const int S = 8; //随机算法判定次数一般 8～10 就够了
// 计算 ret = (a*b)%c a,b,c < 2^63
ll mult_mod(ll a,ll b,ll c){
    a%=c;
    b%=c;
    ll ret=0;
    ll tmp=a;
    while(b){
        if(b&1){
            ret+=tmp;
            if(ret>c)ret-=c;//直接取模慢得多 
        }
        tmp<<=1;
        if(tmp>c)tmp-=c;
        b>>=1;
    }
    return ret;
}
// 计算 ret = (a^n)%mod
ll pow_mod(ll a,ll n,ll mod){
    ll ret=1;
    ll tmp=a%mod;
    while(n){
        if(n&1)ret=mult_mod(ret,tmp,mod);
        tmp=mult_mod(tmp,tmp,mod);
        n>>=1;
    }
    return ret;
}
// 通过 a^(n-1)=1(modn)来判断 n 是不是素数
// n - 1 = x * (2^t)
// 中间使用二次判断
// 是合数返回 true, 不一定是合数返回 false
bool check(ll a,ll n,ll x,ll t){
    ll ret = pow_mod(a,x,n);
    ll last = ret;
    for(int i = 1;i <= t;i++){
        ret = mult_mod(ret,ret,n);
        if(ret == 1 && last != 1 && last != n-1)return true;//合数
        last = ret;
    }
    if(ret != 1)return true; // 费马小定理
    else return false;
}
//**************************************************
// Miller_Rabin 算法
// 是素数返回 true,(可能是伪素数)
// 不是素数返回 false
//**************************************************
bool Miller_Rabin(ll n){
    if( n < 2)return false;
    if( n == 2)return true;
    if( (n&1) == 0)return false;//偶数
    ll x = n - 1;
    ll t = 0;
    while( (x&1)==0 ){x >>= 1; t++;}

    srand(time(NULL));/* *************** */

    for(int i = 0;i < S;i++){
        ll a = rand()%(n-1) + 1;
        if( check(a,n,x,t) )
            return false;
    }
    return true;
}

```
### Pollard-Rho算法
```cpp
#include<iostream>
#include<cstdio>
#include<iomanip>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<ctime>
#include<queue>
#include<vector>
#include<stack>
#include<map>
#include<set>
#define ull unsigned long long
#define lb long double
#define ll long long
#define debug(x) cout<<"###"<<x<<"###"<<endl;
using namespace std;
inline ll Abs(ll x){return x<0?-x:x;}//取绝对值
inline ll gcd(ll x,ll y){//非递归求gcd
    ll z;
    while(y){z=x;x=y;y=z%y;}
    return x;
}
inline ll qMult(ull x,ull y,ll p){//O(1)快速乘（防爆long long）
    return (x*y-(ull)((lb)x/p*y)*p+p)%p;
}
inline ll qPow(ll x,ll y,ll p){//快速幂
    ll res=1;
    while(y){
        if(y&1)res=qMult(res,x,p);
        x=qMult(x,x,p); y>>=1;
    }return res;
}
inline bool Miller_Rabin(ll x,ll p){//mille rabin判质数
    if(qPow(x,p-1,p)!=1)return 0;//费马小定理
    ll y=p-1,z;
    while(!(y&1)){//二次探测
        y>>=1; z=qPow(x,y,p);
        if(z!=1&&z!=p-1)return 0;
        if(z==p-1)return 1;
    }return 1;
}
inline bool prime(ll x){ if(x<2)return 0;//mille rabin判质数
    if(x==2||x==3||x==5||x==7||x==43) return 1;
    return Miller_Rabin(2,x)&&Miller_Rabin(3,x)&&Miller_Rabin(5,x)&&Miller_Rabin(7,x)&&Miller_Rabin(43,x);
}
inline ll Miller_Rabin(ll p){//求出p的非平凡因子
    ll x,y,z,c,g; int i,j;//先摆出来（z用来存（y-x）的乘积）
    while(1){//保证一定求出一个因子来
        y=x=rand()%p;//随机初始化
        z=1; c=rand()%p;//初始化
        i=0,j=1;//倍增初始化
        while(++i){//开始玄学生成
            x=(qMult(x,x,p)+c)%p;//可能要用快速乘
            z=qMult(z,Abs(y-x),p);//我们将每一次的（y-x）都累乘起来
            if(x==y||!z)break;//如果跑完了环就再换一组试试（注意当z=0时，继续下去是没意义的）
            if(!(i%127)||i==j){//我们不仅在等127次之后gcd我们还会倍增的来gcd
                g=gcd(z,p);
                if(g>1)return g;
                if(i==j)y=x,j<<=1;//维护倍增正确性，并判环（一箭双雕）
            }
        }
    }
}
//fac存因子，tot 0~tot-1
ll fac[100000],tot;
inline void findfac(ll p){//不断的找他的质因子
	if(p==1)return;
    if(prime(p)){fac[tot++]=p;return;}
    ll pi=Miller_Rabin(p);//我们一次必定能求的出一个因子，所以不用while
    while(p%pi==0)p/=pi;//记得要除尽
    return findfac(pi),findfac(p);//分开继续分解质因数
}
int main(){
    ll t,n;
    scanf("%lld",&t); srand(time(0));//随机数生成必备！！！
    while(t--){
        scanf("%lld",&n);
        tot=0;
        if(prime(n)){
            printf("Prime\n");continue;
        }
        findfac(n);
        sort(fac,fac+tot);
		printf("%lld\n",fac[tot-1]);
    }
    return 0;
}

```
## 高次同余

### BSGS算法
&ensp;&ensp;用于求$a^x≡b(mod p)$高次方程的最小正整数解$x$,其中$p$为素数。
```cpp
//求解A^x≡B(mod p)  A是底数， B是余数， p是质数，x是未知数 
unordered_map<ll,int>mp;
ll BSGS(ll A,ll B,ll p){
	ll ans;
	mp.clear();
	ll m=ceil(sqrt(p));
	for(ll i=0,t=B;i<=m;i++,t=t*A%p)mp[t]=i; 
	for(ll i=1,tt=binaryPow(A,m,p),t=tt;i<=m;i++,t=t*tt%p){
		if(mp.count(t)){
			ans=(i*m-mp[t]);
			return ans;
		}
	}
	return (ll)-1;	//没有找到返回-1 
}
```

## 组合数学

### 组合数


### 抽屉原理
&ensp;&ensp;把n+1个物体放进n个盒子，至少有一个盒子包含两个或更多盒子

### 容斥原理
&ensp;&ensp;要计算几个集合并集的大小，我们要先将所有单个集合的大小计算出来，然后减去所有两个集合相交的部分，再加回所有三个集合相交的部分，再减去所有四个集合相交的部分，依此类推，一直计算到所有集合相交的部分。

#### 二进制枚举求求【1，n】中与x不互素的数的个数，反过来可求互质的数的个数
```cpp
const int MAXN=5e4+10;//质数表
int primes[MAXN+10],NUM=0;
bool is_prime[MAXN+10];
void GetPrime2(){
    memset(is_prime, true, sizeof(is_prime));
    is_prime[1] = 0;
    for (int i = 2; i <= MAXN; i++) {
        if (is_prime[i])
            primes[NUM++] = i;
        for (int j = 0; j < NUM && i * primes[j] <= MAXN; j++) {
            is_prime[i * primes[j]] = 0;
            if (i % primes[j] == 0)
                break;
        }
    }
}
int fac[Maxn];//分解
int getfac(int x){
    int num=0;
    for(int i=0;i<NUM&&primes[i]<=x;i++){
        if(x%primes[i]==0){
          fac[num++]=primes[i];
          while(x%primes[i]==0){
              x/=primes[i];
          }  
        }
    }
    if(x>1)fac[num++]=x;
    return num;
}
ll solve(int x,int n){//求【1，n】中与x不互素的数的个数
    int num=getfac(x);//分解x
    ll sum=0;
    for(ll i=1;i<(1<<num);i++){
        int mult=1,bits=0;
        for(int j=0;j<num;j++){
            if(i&(1<<j)){
                bits++;mult*=fac[j];//二进制枚举
            }
        }
        ll cur=n/mult;//除得到个数
		//容斥定理 奇数个＋，偶数个-
        if(bits&1) sum+=cur;
        else sum-=cur;
    }
    return sum;
}

```

#### 1.球相同，盒子不同，不能有空盒
&ensp;&ensp;就是把n个球分成m份，每一份不能为空，插m-1个板即可。
$$ans=C_{n-1}^{m-1}$$

#### 2.球相同，盒子不同，可以有空盒
&ensp;&ensp;把n个球分成m份，每一份可以为空，再增加m个球，插 m-1个板，每一份再拿走一个球即可。
$$ans=C_{n+m-1}^{m-1}$$ 

#### 3.球不同，盒子不同，可以有空盒
&ensp;&ensp;对于每一个球，你都可以放到\[1,m]的任意一个位置,由于球不同，所以球与球之间是独立的。
$$ans=m^n$$

#### 4.球不同，盒子相同，不能有空盒
&ensp;&ensp;相当于把n个元素的集合划分成m份，也就是第二类斯特林数.
$$ans = S_n^m$$

#### 5.球不同，盒子不同，不能有空盒

[TOC]
# 一些板子

## 二分模板
```cpp
//ans>=mi,ans<=ma
l=mi,r=ma,mid;
while(l<=r)
{
    mid=(l+r)>>1;
    if(isOk(mid))
    {
        //求最大值
        l=mid+1;
        ans=max(ans,mid);
        //求最小值
        r=mid-1;
        ans=min(ans,mid);
    }
    else
    {
        //求最大值
        r=mid-1;
        //求最小值
        l=mid+1;
    }
}
```
## 尺取模板

```cpp
//ans:答案，n：个数，t给定标准 
void ruler(){
    int l=0,r=0,sum=0;//区间[0，n)
    int ans=0;
    while(1){
        while(r<n&&sum+a[r]<=t){//因为右边是开区间，用r试探，如果下一个满
        //足加起来小于等于t，sum就加它，
            sum+=a[r++];
        }
        ans=max(ans,r-l);
        if(r==n)break;//区间[0，n)
        sum-=a[l++];//l移动
    }
    printf("%d\n",ans);
}
```

## 进制转化和`sscanf`的使用

### 十进制转换k进制

```cpp
#include<cstdio>
#include<iostream>
#include<ctime>
char a[1000];
using namespace std;
int main()
{
    int y=0,k,n,x;
    char z='A';
    scanf ("%d %d",&n,&x);
    while (n!=0)
    {   
          y++;
             a[y]=n%x;
          n=n/x;
          if (a[y]>9) a[y]=z+(a[y]-10); 
          else a[y]=a[y]+'0';
    }
    for (int i=y;i>0;i--)
    printf ("%c",a[i]);
    return 0;
}
```

### M进制转十进制

```cpp
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<cstring>
char a[10000];
using namespace std;
int main()
{
   int n,m;
   int f=0;
   scanf ("%s%d",a,&m);
   for (int i=0;i<strlen(a);i++)
   {
        f*=m;
        if (a[i]=='A'||a[i]=='B'||a[i]=='C'||a[i]=='D'||a[i]=='E'||a[i]=='F')
        {
            f=f+(a[i]-'A'+10);
        }
        else
        {
            f=f+(a[i]-'0');
        }
   }
   printf ("%d",f);
   return 0;
}
```

### 关于`sscanf`

一个字符串中读进与指定格式相符的数据。字符串操作是平常用途之多，截取，追加等等。也经常从文件中读取一行，取出所需要的字符串。基本有些是固定格式的。都可以用`sscanf`来得到。

例如：

```cpp
sscanf(line, "%[A-Z]%d", t, &r);
sscanf(line,"R%dC%d", &r, &c);
```

上述知识点可参见`Codeforces 1B`

https://vjudge.net/contest/387797#problem/B

## 高精度运算

### 高精度存储方法：倒序存储

```cpp
void clear(int a[]) 
{
    for (int i = 0; i < LEN; ++i) a[i] = 0;
}
void read(int a[]) {
  static char s[LEN + 1];
  scanf("%s", s);
  clear(a);
  int len = strlen(s);
  // 如上所述，反转
  for (int i = 0; i < len; ++i) a[len - i - 1] = s[i] - '0';
  // s[i] - '0' 就是 s[i] 所表示的数码
}
```

### 高精度输出：倒序输出

```cpp
void print(int a[]) {
  int i;
  for (i = LEN - 1; i >= 1; --i)
    if (a[i] != 0) break;
  for (; i >= 0; --i) putchar(a[i] + '0');
  putchar('\n');
}
```

### 高精度加法

```cpp
void add(int a[], int b[], int c[]) {
  clear(c);
  // 高精度实现中，一般令数组的最大长度 LEN 比可能的输入大一些
  // 然后略去末尾的几次循环，这样一来可以省去不少边界情况的处理
  // 因为实际输入不会超过 1000 位，故在此循环到 LEN - 1 = 1003 已经足够
  for (int i = 0; i < LEN - 1; ++i) {
    // 将相应位上的数码相加
    c[i] += a[i] + b[i];
    if (c[i] >= 10) {
      // 进位
      c[i + 1] += 1;
      c[i] -= 10;
    }
  }
}
```

### 高精度减法：

```cpp
void sub(int a[], int b[], int c[]) {
  clear(c);
  for (int i = 0; i < LEN - 1; ++i) {
    // 逐位相减
    c[i] += a[i] - b[i];
    if (c[i] < 0) {
      // 借位
      c[i + 1] -= 1;
      c[i] += 10;
    }
  }
}
```

### 高精度乘法：高精度—单精度

```cpp
void mul_short(int a[], int b, int c[]) {
  clear(c);
  for (int i = 0; i < LEN - 1; ++i) {
    // 直接把 a 的第 i 位数码乘以乘数，加入结果
    c[i] += a[i] * b;
    if (c[i] >= 10) {
      // 处理进位
      // c[i] / 10 即除法的商数成为进位的增量值
      c[i + 1] += c[i] / 10;
      // 而 c[i] % 10 即除法的余数成为在当前位留下的值
      c[i] %= 10;
    }
  }
}
```

### 高精度乘法：高精度—高精度

```cpp
void mul(int a[], int b[], int c[]) {
  clear(c);
  for (int i = 0; i < LEN - 1; ++i) {
    // 这里直接计算结果中的从低到高第 i 位，且一并处理了进位
    // 第 i 次循环为 c[i] 加上了所有满足 p + q = i 的 a[p] 与 b[q] 的乘积之和
    // 这样做的效果和直接进行上图的运算最后求和是一样的，只是更加简短的一种实现方式
    for (int j = 0; j <= i; ++j) c[i] += a[j] * b[i - j];

    if (c[i] >= 10) {
      c[i + 1] += c[i] / 10;
      c[i] %= 10;
    }
  }
}
```

### 高精度除法

```cpp
// 被除数 a 以下标 last_dg 为最低位，是否可以再减去除数 b 而保持非负
// len 是除数 b 的长度，避免反复计算
inline bool greater_eq(int a[], int b[], int last_dg, int len) {
  // 有可能被除数剩余的部分比除数长，这个情况下最多多出 1 位，故如此判断即可
  if (a[last_dg + len] != 0) return true;
  // 从高位到低位，逐位比较
  for (int i = len - 1; i >= 0; --i) {
    if (a[last_dg + i] > b[i]) return true;
    if (a[last_dg + i] < b[i]) return false;
  }
  // 相等的情形下也是可行的
  return true;
}

void div(int a[], int b[], int c[], int d[]) {
  clear(c);
  clear(d);
  int la, lb;
  for (la = LEN - 1; la > 0; --la)
    if (a[la - 1] != 0) break;
  for (lb = LEN - 1; lb > 0; --lb)
    if (b[lb - 1] != 0) break;
  if (lb == 0) {
    puts("> <");
    return;
  }  // 除数不能为零

  // c 是商
  // d 是被除数的剩余部分，算法结束后自然成为余数
  for (int i = 0; i < la; ++i) d[i] = a[i];
  for (int i = la - lb; i >= 0; --i) {
    // 计算商的第 i 位
    while (greater_eq(d, b, i, lb)) {
      // 若可以减，则减
      // 这一段是一个高精度减法
      for (int j = 0; j < lb; ++j) {
        d[i + j] -= b[j];
        if (d[i + j] < 0) {
          d[i + j + 1] -= 1;
          d[i + j] += 10;
        }
      }
      // 使商的这一位增加 1
      c[i] += 1;
      // 返回循环开头，重新检查
    }
  }
}
```

### 压位高精度

```cpp
//这里的 a,b,c 数组均为 p 进制下的数
//最终输出答案时需要将数字转为十进制
void add(int a[], int b[], int c[]) {
  clear(c);
  for (int i = 0; i < LEN - 1; ++i) {
    c[i] += a[i] + b[i];
    if (c[i] >= p) {  //在普通高精度运算下，p=10
      c[i + 1] += 1;
      c[i] -= p;
    }
  }
}
```

## 尺取法

尺取法：顾名思义，像尺子一样取一段，尺取法通常是对数组保存一对下标，即所选取的区间的左右端点，然后根据实际情况不断地推进区间左右端点以得出答案。**尺取法比直接暴力枚举区间效率高很多**，尤其是数据量大的时候，所以说尺取法是一种高效的枚举区间的方法，是一种技巧，**一般用于求取有一定限制的区间个数或最短的区间**等等。当然任何技巧都存在其不足的地方，有些情况下尺取法不可行，无法得出正确答案，所以要先判断是否可以使用尺取法再进行计算

使用尺取法时应清楚以下四点：1、 什么情况下能使用尺取法?  2、何时推进区间的端点？ 3、如何推进区间的端点？ 4、何时结束区间的枚举？

 尺取法通常适用于**选取区间有一定规律，或者说所选取的区间有一定的变化趋势的情况**，通俗地说，在对所选取区间进行判断之后，我们可以明确如何进一步有方向地推进区间端点以求解满足条件的区间，如果已经判断了目前所选取的区间，但却无法确定所要求解的区间如何进一步得到根据其端点得到，那么尺取法便是不可行的。首先，明确题目所需要求解的量之后，区间左右端点一般从最整个数组的起点开始，之后判断区间是否符合条件在根据实际情况变化区间的端点求解答案。

例题：https://ac.nowcoder.com/acm/contest/5674/F

参考AC代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int maxn = 2e6 + 17;
int vis[maxn] = {0};
struct Node{
    int x,line;
}N[maxn];
bool cmd(Node a,Node b)
{
    return a.x < b.x;
}
int main()
{
    int n,m,num = 0;
    scanf("%d%d",&n,&m);
    for(int i = 1;i <= n;i++){
        int k;
        scanf("%d",&k);
        for(int j = 1;j <= k;j++){
            scanf("%d",&N[++num].x);
            N[num].line = i;
        }
    }
    sort(N + 1,N + 1 + num,cmd);
    int l = 1,r = m,temp = 0,ans = 0x3f3f3f3f;
    for(int i = l;i <= r;i++){
        if(!vis[N[i].line]) {
            vis[N[i].line]++;
            temp++;
        }
    }
    while(temp < m){
        r++;
        if(!vis[N[r].line]) {
            vis[N[r].line]++;
            temp++;
        }
    }
    for(l,r;l <= r && r <= num;){
        ans = min(ans,N[r].x - N[l].x);
        vis[N[l].line]--;l++;
        if(vis[N[l - 1].line] == 0) temp--;
        while(r <= num && temp < m){
            r++;
            if(!vis[N[r].line]) {
                vis[N[r].line]++;
                temp;
            }
        }
    }
    printf("%d\n",ans);
    return 0;
}
```


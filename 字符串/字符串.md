[TOC]
# 字符串

## 字符串哈希
下标从1开始
```cpp
typedef unsigned long long ull;
ull p[Maxn],hs[Maxn];
const ull base = 131;
void init(){
    p[0] = 1;
    for(int i=1;i<Maxn;i++){
            p[i] = p[i-1]*base;
    }
}
void InitStrHash(char s[] ){
    int tlen = strlen(s+1);
    hs[0] = 0;
    for ( int i=1;i<=tlen;i++)
        hs[i] = hs[i-1]*base+(ull)s[i];
}
ull GetHash( int l , int r ){
    return (ull)hs[r]-p[r-l+1]*hs[l-1];
} 
```



## KMP算法
参见《算法竞赛进阶指南的模板》

## 字典树
参见《算法竞赛进阶指南的模板》
## ac自动机
```cpp
#include <bits/stdc++.h>

#define ill __int128
#define ll long long
#define PII pair <ll,ll>
#define ull unsigned long long
#define me(a,b) memset (a,b,sizeof(a))
#define rep(i,a,b) for (int i = a;i <= b;i ++)
#define req(i,a,b) for (int i = a;i >= b;i --)
#define ios std :: ios :: sync_with_stdio(false)

const double Exp = 1e-9;
const int INF = 0x3f3f3f3f;
const int inf = -0x3f3f3f3f;
const int mode = 1000000007;
const double pi = acos(-1);

using namespace std;

const int maxn = 1e6 + 10;
int n, trie[maxn][26], fail[maxn * 26], End[maxn * 26], tot;
string t[maxn], str;
queue<int > q;

inline void insert(string s)   //建立字典树
{
    int len = s.length(), p = 0;
    for (int i = 0;i < len;i ++) {
        int ch = s[i] - 'a';
        if (trie[p][ch] == 0) trie[p][ch] = ++ tot;
        p = trie[p][ch];
    }
    End[p] ++;
    return ;
}

inline void buildTrie() //建立字典图
{
    int p = 0;
    for (int i = 0;i < 26;i ++) if (trie[p][i]) q.push(trie[p][i]);
    while (!q.empty()) {
        int now = q.front();
        q.pop();
        for (int i = 0;i < 26;i ++) {
            if (trie[now][i]) {
                fail[trie[now][i]] = trie[fail[now]][i];
                q.push(trie[now][i]);
            }
            else trie[now][i] = trie[fail[now]][i];
        }
    }
    return ;
}

inline int ask(string s)   //询问模式串
{
    int len = s.length(), p = 0, ans = 0;
    for (int i = 0;i < len;i ++) {
        p = trie[p][s[i] - 'a'];
        for (int j = p;j && End[j];j = fail[j]) {
            if (End[j]) {
                ans += End[j];
                End[j] = 0;
            }
        }
    }
    return ans;
}

int main()
{
    cin >> n;
    for (int i = 1;i <= n;i ++) {
        cin >> t[i];
        insert(t[i]);
    }
    buildTrie();
    cin >> str;
    cout << ask(str) << endl;
    return 0;
}
```

## 马拉车算法

```c++
void init()
{
    str[k++] = '@';
    for(int i = 0;i < len;i++)
    {
        str[k++] = '#';
        str[k++] = ss[i];
    }
    str[k++] = '#';
    len = k;
    str[k] = 0;
}
 
int manacher()
{
    int mx = 0,id = 0;
    int maxx = 0;
    for(int i = 1;i < len;i++)
    {
        if(mx > i) Len[i] = min(mx - i,Len[2 * id - i]);
        else Len[i] = 1;
        while(str[i + Len[i]] == str[i - Len[i]]) Len[i]++;
        if(Len[i] + i > mx)
        {
            mx = Len[i] + i;
            id = i;
            maxx = max(maxx,Len[i]);
        }
    }
    return (maxx - 1);
}
```


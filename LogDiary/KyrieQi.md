## 10.31

整合了前面几天做的思维题，进行了一次比较集中的[补题](https://vjudge.net/contest/463722)。下面陈述几个印象比较深的题目：

感觉Atcoder的题目思维都还可以，Beginner Contest的题目比较适合训练思维。

### [AtCoder - abc223_f ](https://vjudge.net/problem/AtCoder-abc223_f/origin)

括号序列的合法性问题，但是需要支持交换任意两个位置的括号，同时需要满足查找区间$[l,r]$内括号序列是否合法。

区间讨论还是优先想的线段树，可以把左括号作为1，右括号作为-1，这样区间内序列合法的条件就是：$str[l] = '(' \enspace \& \enspace str[r] = ')' \enspace \& \enspace sum[l,r] = 0 \enspace \& \enspace sum[l,r] = min$

解释一下就是：左右端点必须是$()$的匹配对，同时$[l,r]$区间和为0，还要满足$sum[l,r] \le sum[l,i] (l \le i < r)$

同时满足上述条件的为合法序列。

直接上线段树然后维护一个区间最小值就可以。



### [CodeForces - 1579F](https://vjudge.net/problem/CodeForces-1579F/origin)

这个题的话一开始猜了一个玄学的思路，认为有限次循环移位以后应该都可以成为全0序列。但是后面发现，序列中已经是0的位置，不管之后经过多少次变换，它和任何数做与运算都是0，所以我们关心的其实就是每一次变换新增多少个0，然后最后扫一遍序列看一下是不是全0即可。

我们可以把序列中原本是0的位置放在一个队列里，然后以此出队，经过$d$的循环移位之后它的位置来到了$now = (i + d) \% len$，如果此时$a[now]  =1$，我们把当前的位置的值置为0，然后把这个位置入队。



### [CodeForces - 1579E2 ](https://vjudge.net/problem/CodeForces-1579E2/origin)

各一个序列，然后按照`deque`的规则模拟以此入队，询问可以构建的序列中，逆序对最小值是多少。

其实需要比较的就是当前队内比他大的数和比他小的数的大小，如果比它大的数多就放在队头否则就放在队尾。于是想到可以使用树状数组，这里把需要维护的区间再拓展一倍，也就是$2n$的长度，这一变化是为了更好的维护区间和插入值。每一次我们比较$ask(a[i] - 1)$和$ask(2n) - ask(a[i])$的大小，然后分别执行$add(-- l, 1)$和$add(++r, 1)$，这里$r = l = n$。



## 11.1

补作业...

晚上还有答辩白天还得准备材料，晚上弄完优团的事情赶着写出入党申请书...

吐了.....

明天再写写CF



## 11.2

正常比赛.....

E和I题感觉在签到题里面算是比较难的了，基本上开出这两个在加上一道`Path`就能进前150了。

大概说一下E和I的思路：

### [E - String](https://vjudge.net/problem/HDU-6586)

基本的思路就是用队列维护每一个字母在原字符串中出现的次数，然后同时求一个后缀和数组，$sum[i][j]$表示第$i$个位置之后的字母$j$有多少个。这样的话我们对于$k$个位置，每一个位置从`a`开始放，能过放入答案序列的条件就是：

1. 放入该字母后，这个字母剩下的数量加上答案序列中已经有的数量要比最小值大。
2. 同时，对于其他字母，满足答案序列中剩余的空位可以满足最差的情况，也就是最终答案序列中的字母数量都是对应的最小值，但同时不能大于最大值。
3. 如果1，2不满足那就不存在这样的序列



### [I - Vacation](https://vjudge.net/problem/HDU-6581)

本场的真实签到题，但是实际情况却是比`Path`过的都少

问题的关键在于，我们需要确定最终的车队是以那一辆车的车速通过的。

所以我们要做的就是遍历一遍车队，用时最长的就是答案，因为这样说明最后的车队一定会接在这个车的后面，统一按照这个车的车速走。

还有一道dp + SAM...有机会看看。
